0) 原创的一套泛型源代码，用于改善STL的易用性，效率，功能增强。

发布日期: 2013-06-14 04:10:55
原文链接: https://blog.csdn.net/Tonny0832/article/details/9093391

---

总结自己这些年来的编程经验，深感大家都不太爱使用成熟的泛型源代码算法，因为这些算法使用比较麻烦，有时甚至得不偿失，比如没有(时间/空间)效率优化，使用stl算法比自己写算法编程更慢(因为需要提供算法的配套接口)，算法的功能不够。

自己实现本来属于算法领域内的一些通用功能，有这样一些缺陷：

1\. 增加了代码工作量，降低开发速度。（自己做了库应该做的工作）

2\. 自己写枯燥的千篇一律的算法(sort/find)，也容易出错，出错了也不好查找，不符合代码复用的原则。

3\. 同时由于hit cache的原因，频繁调用的函数效率更高。

4\. 自己写一个特定功能的算法很少考虑效率问题，有可能写出比STL通用算法效率更低的算法出来。

为了解决这些问题，改善代码质量，提供通用性更强，效率更高，用户工作量更少的库代码，我自己根据自己的编程经验，主要利用业余时间写了一套泛型的源代码库，应该在自己的工作中。同时也对STL的容器和经典的容器(数组)进行了统一封装，让用户既可以按STL容器的使用习惯来使用经典数组，也可以按经典数组的使用习惯来使用STL容器。(方便C程序员的思维)。

自己的这套库的一些功能点：

对结构体进行操作时，经常是对结构体中的某个成员进行操作，如比较排序，累加，查找等，以下泛型代码可以对任意结构体完成下列功能，这些代码可以无缝地作为各种泛型算法的第三个参数.

1\. 易用性  
如果不用boost支持，大家一般对复杂结构体容器不使用std::sort,std::find吧，因为我们要写额外的结构体比较函数，这是STL留给用户的负担。仅仅为使用STL通用算法，而对于每个结构/类都写这样一个比较函数，大多数人宁愿不用STL的算法，而直接自己写这些sort/find函数，这就是STL易用性的缺陷。本源代码可以承担这些负担，用户可以直接比较任意(同/不同)类型的结构体而不需要提供结构体比较函数---因为复杂结构体的比较往往是落实到最终某个原子成员数据的比较。  
2\. STL算法效率问题。  
对于复杂结构体，因为效率的原因，有些需要使用比较优先的算法(比如大对象)，有些应该使用copy优先的算法(比如小的原子对象)，这些STL算法都没有考虑到，本源代码在算法内部会考虑这些问题从而平衡使用，以提高STL算法的效率。  
3\. 扩展性  
比如对于std::find，如果用户不自定义最后一个参数，那么找到的通常是第一个找到值，而有时候，我们可能需要的不是第一个找到的值，而是第二个，第三个，第m-n个一组值，倒数4个，倒数第5个值，这些STL的算法都做不到，除非用户自己写STL算法的最后一个参数。本源代码库可以帮助用户不必写定制最后一个参数，而直接获得这些复杂的功能。另外就是STL算法中提供的函数对象过少并且功能过于简单，MS的std::tr1中提供的函数对象使用又比较复杂，除非频繁使用，否则使用时要找参考。

自己写的这套源代码提供了更多的泛型函数对象，可以以尽量简单的方式向用户提供复杂的功能。

－－-------------------------------

有兴趣的朋友可以在我的资源中下载源代码及用法/测试代码

<https://github.com/shenxiaolong-code/MiniMPL>
