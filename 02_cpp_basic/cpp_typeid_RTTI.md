typeid及RTTI

发布日期: 2013-10-10 10:27:49
原文链接: https://blog.csdn.net/Tonny0832/article/details/12558827

---

C＋＋中类型识别符typeid分静态识别和动态识别。

静态识别是指在编译阶段进行的识别，动态识别是指在运行阶段进行的识别。

只有动态识别需要RTTI的支持，但是RTTI是否打开不影响编译链接，只影响运行结果是否正确。

typeid的工作原理：

1\. typeid是依赖于保存在虚函数表里面的type_info块来获取真实对象信息的。而如果基类没有任何虚函数的话，typeid就没法在运行期获得动态的对象类型信息。取而代之的是，typeid会将exp作为静态类型的表达式对待。

2\. 如果把RTTI(运行时类型识别)关掉，那么虽然类的多态能力还具有，虚函数表也会在需要的时候现身，但是虚函数表就不会携带一块type_info信息了，从而使得typeid同样无法在运行期获得动态对象类型信息.

即，对于typeid(exp)而言：

1\. 当RTTI能力被编译环境关掉时，那么typeid(exp)总是在编译期决定exp的类型，即静态类型。

2\. 当RTTI能力开启时，分两种情况： 

1) 如果exp的类型是内建类型或者不包含任何虚函数(无论是自己包含还是从基类继承而来)的class，那么typeid(exp)将返回exp的编译期静态类型。

2) 如果exp是含有虚函数的class，那么typeid(exp)将返回从type_info获取的动态对象类型信息。

RTTI的影响：

如果关闭了RTTI，编译器不会向类的虚函数表(如果有的话)增加type_info信息，而dynamic_cast及typeid都依赖于type_info才能正常工作。

1) dynamic_cast的运行结果：如果基类中无虚函数表，则编译失败；如果基类的虚函数的话，编译链接成功，但dynamic_cast实际只相当于C语言的中强制类型转换，不会做任何有意义的探测工作，即转换总是成功的――不会返回NULL或者抛出异常，这明显是违反逻辑的。

typeid操作符在没有type_info的支持下，只能做编译期的静态判别：永远返回操作符对象定义类型(往往是基类)，而不会返回实际的派生类。 
